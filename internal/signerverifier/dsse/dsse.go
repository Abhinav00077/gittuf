package dsse

import (
	"context"
	"encoding/base64"

	"github.com/adityasaky/gittuf/internal/signerverifier"
	"github.com/adityasaky/gittuf/internal/signerverifier/ed25519"
	"github.com/secure-systems-lab/go-securesystemslib/dsse"
)

// SignEnvelope is an opinionated API to sign TUF metadata. It's opinionated
// because it assumes the payload is Base 64 encoded, which is the expectation
// for TUF metadata generated by gittuf.
func SignEnvelope(ctx context.Context, envelope *dsse.Envelope, signingKeyContents []byte) (*dsse.Envelope, error) {
	// TODO: pass off to generic LoadSigner
	signer, err := ed25519.NewSignerVerifierFromSecureSystemsLibFormat(signingKeyContents)
	if err != nil {
		return nil, err
	}

	keyID, err := signer.KeyID()
	if err != nil {
		return nil, err
	}

	payload, err := base64.StdEncoding.DecodeString(envelope.Payload)
	if err != nil {
		return nil, err
	}

	pae := dsse.PAE(envelope.PayloadType, payload)
	signature, err := signer.Sign(ctx, pae)
	if err != nil {
		return nil, err
	}

	envelope.Signatures = append(envelope.Signatures, dsse.Signature{
		Sig:   base64.StdEncoding.EncodeToString(signature),
		KeyID: keyID,
	})

	return envelope, nil
}

// VerifyEnvelope verifies a DSSE envelope against an expected threshold using
// a slice of public keys passed in to it. Threshold indicates the amount of
// providers that must validate the envelope.
func VerifyEnvelope(ctx context.Context, envelope *dsse.Envelope, publicKeys [][]byte, threshold int) error {
	if threshold < 1 || threshold > len(publicKeys) {
		return signerverifier.ErrInvalidThreshold
	}

	verifiers := []dsse.Verifier{}
	for _, k := range publicKeys {
		// TODO: pass off to generic LoadVerifier
		v, err := ed25519.NewSignerVerifierFromSecureSystemsLibFormat(k)
		if err != nil {
			return err
		}
		verifiers = append(verifiers, dsse.Verifier(*v))
	}

	ev, err := dsse.NewMultiEnvelopeVerifier(threshold, verifiers...)
	if err != nil {
		return err
	}

	_, err = ev.Verify(ctx, envelope)
	return err
}
